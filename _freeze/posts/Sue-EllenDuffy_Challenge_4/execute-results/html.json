{
  "hash": "9e288f43bd5b429f5e2c399d93bada36",
  "result": {
    "markdown": "---\ntitle: \"Challenge 4 Egg Data\"\nauthor: \"Sue-Ellen Duffy\"\ndescription: \"Data wrangling: Mutate\"\ndate: \"03/22/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_4\n  - Sue-Ellen Duffy\n  - eggs\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readr)\nlibrary(readxl)\nlibrary(lubridate)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n\n### Egg Data, Round 2\nHere we have the monthly price paid by first receivers for USDA Certified Organic Eggs by size and carton types for January 2004 to December 2013. The unit \"Price\" is \"cents per pound\". So, for example in January 2004, the price paid by first receivers for USDA Certified Dozen of Extra Large Eggs was 230 cents/pound. As defined in the original data, First Receivers \"those entities that purchases the processed product from the poultry or egg company, such as a retailer, distributor, or manufacturer\". The term wholesale level would be appropriate in many cases. \n\n## Read in the Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\neggs_og <- read_excel(\"_data/organiceggpoultry.xls\",\n                      sheet=\"Data\",\n                      range =cell_limits(c(6,2),c(NA,6)),\n                      col_names = c(\"date\", \"xlarge_dzn\", \"xlarge_halfdzn\", \"large_dzn\", \"large_halfdzn\")\n)\neggs_og\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 120 × 5\n   date      xlarge_dzn xlarge_halfdzn large_dzn large_halfdzn\n   <chr>          <dbl>          <dbl>     <dbl>         <dbl>\n 1 Jan 2004        230            132       230           126 \n 2 February        230            134.      226.          128.\n 3 March           230            137       225           131 \n 4 April           234.           137       225           131 \n 5 May             236            137       225           131 \n 6 June            241            137       231.          134.\n 7 July            241            137       234.          134.\n 8 August          241            137       234.          134.\n 9 September       241            136.      234.          130.\n10 October         241            136.      234.          128.\n# … with 110 more rows\n```\n:::\n:::\n\n::: callout-Tip\n## Date Format 1\nStarting off a little messy. Already I see this data is -wide- and the date needs formatting. Let's see what other nuances might be lingering in the date column (count).\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(select(eggs_og, date))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndate\n      April      August    December    February February /1    Jan 2004 \n         10          10          10           8           2           1 \n   Jan 2005    Jan 2006    Jan 2007    Jan 2008    Jan 2009    Jan 2010 \n          1           1           1           1           1           1 \n   Jan 2011    Jan 2012    Jan 2013        July        June       March \n          1           1           1          10          10          10 \n        May    November     October   September \n         10          10          10          10 \n```\n:::\n:::\n\n::: callout-Tip\n## Date Format 2\nIn the date column, January has a year indicator, 10 of the months appear 10 times, February appears 8 times and February/1 (a leap year) appears twice. We have to delete the /1 in February (mutate) and extend the year indicator from January to the rest of the months (separate and fill).\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neggs <- eggs_og %>%\n  mutate(date = str_remove(date, \" /1\")) %>%\n  separate(date, into=c(\"month\", \"year\"), sep=\" \") %>%\n  fill(year)\neggs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 120 × 6\n   month     year  xlarge_dzn xlarge_halfdzn large_dzn large_halfdzn\n   <chr>     <chr>      <dbl>          <dbl>     <dbl>         <dbl>\n 1 Jan       2004        230            132       230           126 \n 2 February  2004        230            134.      226.          128.\n 3 March     2004        230            137       225           131 \n 4 April     2004        234.           137       225           131 \n 5 May       2004        236            137       225           131 \n 6 June      2004        241            137       231.          134.\n 7 July      2004        241            137       234.          134.\n 8 August    2004        241            137       234.          134.\n 9 September 2004        241            136.      234.          130.\n10 October   2004        241            136.      234.          128.\n# … with 110 more rows\n```\n:::\n:::\n\n\n::: callout-Tip\n## Date Format 3\nWe need to mutate the Month and Year into one combined date. In order to do that we would mutate and make_date time. However when I try that I get an error. I'm not entirely sure why. I tried renaming Jan to January to see if that was the issue. It still won't let me so I will just use the mutate and str_c functions to create the date column.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\neggs<-eggs %>%\n  mutate(month=recode (month, 'Jan'='January')) %>%\n  mutate(date = str_c(month, year, sep=\" \"),\n         date = my(date))\nselect(eggs, month, year, date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 120 × 3\n   month     year  date      \n   <chr>     <chr> <date>    \n 1 January   2004  2004-01-01\n 2 February  2004  2004-02-01\n 3 March     2004  2004-03-01\n 4 April     2004  2004-04-01\n 5 May       2004  2004-05-01\n 6 June      2004  2004-06-01\n 7 July      2004  2004-07-01\n 8 August    2004  2004-08-01\n 9 September 2004  2004-09-01\n10 October   2004  2004-10-01\n# … with 110 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neggs<-eggs%>%\n  mutate(date = make_datetime(month, year))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `date = make_datetime(month, year)`.\nCaused by error:\n! Invalid input type, expected 'integer' actual 'character'\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}