{
  "hash": "95f98e52a6beefab2a768cfcdf338571",
  "result": {
    "markdown": "---\ntitle: \"Challenge 5\"\nauthor: \"Connor Landreth\"\ndescription: \"Visualization\"\ndate: \"2023-03-26\"\nformat:\n  html:\n    toc: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_5\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1)  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2)  tidy data (as needed, including sanity checks)\n3)  mutate variables as needed (including sanity checks)\n4)  create at least two univariate visualizations\n   - try to make them \"publication\" ready\n   - Explain why you choose the specific graph type\n5)  Create at least one bivariate visualization\n   - try to make them \"publication\" ready\n   - Explain why you choose the specific graph type\n\n[R Graph Gallery](https://r-graph-gallery.com/) is a good starting point for thinking about what information is conveyed in standard graph types, and includes example R code.\n\n(be sure to only include the category tags for the data you use!)\n\n## Read in data\n\nRead in one (or more) of the following datasets, using the correct R package and command.\n\n-   cereal.csv ⭐\n-   Total_cost_for_top_15_pathogens_2018.xlsx ⭐\n-   Australian Marriage ⭐⭐ \n-   AB_NYC_2019.csv ⭐⭐⭐\n-   StateCounty2012.xls ⭐⭐⭐\n-   Public School Characteristics ⭐⭐⭐⭐ \n-   USA Households ⭐⭐⭐⭐⭐\n\nsetwd(\"C:/Github Projects/601_Spring_2023/posts/_data\")\n\nmarriage <- read.csv(\"australian_marriage_tidy.csv\")\n\nEven though this dataset is small and one could simply eye through the set to identify regions where people are predominately unmarried.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(marriage)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.data.frame(x): object 'marriage' not found\n```\n:::\n\n```{.r .cell-code}\nmarriage %>% \n  count(resp)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in count(., resp): object 'marriage' not found\n```\n:::\n\n```{.r .cell-code}\ndf1 <- marriage %>% \n  select(resp, territory, percent) %>%\n  filter(resp == \"no\") %>% \n  filter(percent > 50)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in select(., resp, territory, percent): object 'marriage' not found\n```\n:::\n\n```{.r .cell-code}\nView(df1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.data.frame(x): object 'df1' not found\n```\n:::\n:::\n\nBy filtering only people who responded no at a rate of over 50%, it is clear every region has more married people than not. So, we will filter differently.\n\nlibrary(ggplot2)\ninstall.packages(\"ggthemes\")\nlibrary(ggthemes)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\ninstall.packages(\"ggthemes\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in contrib.url(repos, \"source\"): trying to use CRAN without setting a mirror\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggthemes)\n\npvar = c(57.8, 64.9, 60.7, 62.5, 63.7, 63.6, 60.6, 74.0)\n  order(pvar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 7 3 4 6 5 2 8\n```\n:::\n\n```{.r .cell-code}\n  pvar[order(pvar)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 57.8 60.6 60.7 62.5 63.6 63.7 64.9 74.0\n```\n:::\n\n```{.r .cell-code}\n  pvar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 57.8 64.9 60.7 62.5 63.7 63.6 60.6 74.0\n```\n:::\n\n```{.r .cell-code}\nmarriage %>% \n  filter (resp %in% c(\"yes\")) %>% \n  ggplot(mapping = aes(x = percent,\n                       y = territory,\n                       labs(title = \"Response Count by Territory\",\n                            y = \"Territory\",\n                            x = \"Percentage\" )))+\n\n  theme_economist()+\n  scale_color_economist()+\n  geom_point(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in filter(., resp %in% c(\"yes\")): object 'marriage' not found\n```\n:::\n:::\n\nAustralian Capital Territory can be seen as clearly having the greatest percent of the population married, at almost 75%. New South Wales is on the other side of the spectrum, at nearly 55%.\n\nnext we'll attempt to look at the count with a density map.\n\n::: {.cell}\n\n```{.r .cell-code}\nclimb %>% \n  filter(resp == \"yes\") %>% \n  ggplot(aes(count, territory, color=count))+\n  geom_point(size=3, alpha = 0.8)+\n  geom_smooth()+\n  theme_linedraw()+\n  labs(title=\"Count by Territory\",\n       x = \"Number of Married Individuals\",\n       y = \"Territory\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in filter(., resp == \"yes\"): object 'climb' not found\n```\n:::\n:::\n\nWhy is it important that we do this? Because looking at the graph of percentage, Australian Capital Territory is vastly dominant in terms of how many individuals are married while New South Wales lags in the very back. However, when looking at count, we see that new South Wales has a much larger count and the Capital Territory has nearly the smallest count. Because of this, we can assume the greater the count, the more likely the percentage is to fall.\n\nBelow, we'll take a closer look at the differences between the two.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNSW.compare <- marriage %>% \n  select(resp, count, percent, territory) %>% \n  arrange(territory) %>% \n  filter(territory %in% c(\"New South Wales\", \"Australian Capital Territory(c)\")) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in select(., resp, count, percent, territory): object 'marriage' not found\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nNSW.compare %>% \n  ggplot(mapping = aes(x = count))+\n  geom_boxplot(fill=\"steelblue\")+\n  theme_classic()+\n  labs(title = \"Count by Territoy\",\n       x = \"percent\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in ggplot(., mapping = aes(x = count)): object 'NSW.compare' not found\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}