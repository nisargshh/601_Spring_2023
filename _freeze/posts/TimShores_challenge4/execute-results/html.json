{
  "hash": "7b7af0f7220e75ce8dca72773f3fb956",
  "result": {
    "markdown": "---\ntitle: \"Challenge 4\"\nauthor: \"Tim Shores\"\ndescription: \"More data wrangling: pivoting\"\ndate: \"03/18/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n    link-external-icon: true\n    link-external-newwindow: true\n    link-external-filter: '^(?:http:|https:)\\/\\/www\\.quarto\\.org\\/custom'\ncategories:\n  - challenge_4\n  - eggs\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: setup\n#| warning: false\n#| message: false\n\nmy_packages <- c(\"tidyverse\", \"readxl\", \"knitr\", \"zoo\") # create vector of packages\ninvisible(lapply(my_packages, require, character.only = TRUE)) # load multiple packages\n\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nChallenge 4 includes four tasks:\n\n1)  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2)  tidy data (as needed, including sanity checks)\n3)  identify variables that need to be mutated\n4)  mutate variables and sanity check all mutations\n\n## Task 1) Read in, Tidy, and Describe the Data\n\nI chose to read in the organic egg file, organiceggpoultry.xls. I use the same process as in [my Challenge 3 submission](https://dacss.github.io/601_Spring_2023/posts/TimShores_challenge3.html){.external target=\"_blank\"}. I left out the details in this post, and show only the first 18 of 1,080 lines of the final data frame.\n\nI also use `mutate` and `case_match` to convert `price` strings to `0`. I could also remove these rows but I think it's better to leave them and document that `0` means there were too few cases to make an observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistEggDFs <- map(set_names(excel_sheets(\"../posts/_data/organiceggpoultry.xls\")),\nread_xls, path = \"../posts/_data/organiceggpoultry.xls\") # read in all sheets as dataframes in a list\n\ndf_eggPoultryData <- map(names(listEggDFs), ~assign(.x, listEggDFs[[.x]], envir = .GlobalEnv))[[1]] # assign the first df in the list to a separate df\n\nproductname <- c(word(df_eggPoultryData[2,1], -1),word(df_eggPoultryData[2,7], -1)) # Store last word from header values in list variables for use after pivot.\n\ncolnames(df_eggPoultryData) <- df_eggPoultryData[4, ] # Assign values from the 4th populated row to column names\ncolnames(df_eggPoultryData)[1] <- \"month\" # source data has no name in date column\n\ndf_eggPoultryData <- df_eggPoultryData %>% \n  slice(-(1:4)) %>% # Slice off the first four rows, which do not have table data.\n  select(!`NA`) %>% # Select all columns but the empty one in the middle\n  separate_wider_delim(month, delim = \" \", names = c(\"month\", \"year\"), too_few = \"align_start\", too_many = \"merge\") %>% \n  mutate(month = replace(month, month == 'Jan', 'January')) %>%\n  mutate(year = replace(year, year == '/1', NA)) %>%\n  fill(year) %>% # tidy the month column and separate year into its own column. \n  pivot_longer(cols = -c(month,year), names_to = \"item\", values_to = \"price\") %>% # to pivot the egg and chicken product column headings into row values under a new `item` column, with their values listed in a `price` column\n  mutate(item = str_remove_all(item, '\\\\n')) %>% # tidy up item values and make labels consistent\n  mutate(item = str_remove_all(item, '1/2 Dozen')) %>%\n  mutate(item = str_replace_all(item, 'Doz\\\\.','Dozen')) %>%\n  mutate(product = case_when( # assign the egg and chicken product variables that I recorded earlier according to each egg and chicken item\n    str_detect(item, regex(\"^[EL]\")) ~ productname[[1]],\n    str_detect(item, regex(\"^[BTW]\")) ~ productname[[2]]\n    )) %>% \n  mutate(price = case_match(price, \"too few\" ~ NA, .default = as.double(price))) %>% # make column all double and NA\n  print(n=18) # print a sample of the table\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,080 × 5\n   month    year  item                  price product\n   <chr>    <chr> <chr>                 <dbl> <chr>  \n 1 January  2004  Extra Large Dozen      230  Eggs   \n 2 January  2004  Extra Large 1/2 Dozen  132  Eggs   \n 3 January  2004  Large Dozen            230  Eggs   \n 4 January  2004  Large 1/2 Dozen        126  Eggs   \n 5 January  2004  Whole                  198. Chicken\n 6 January  2004  B/S Breast             646. Chicken\n 7 January  2004  Bone-in Breast          NA  Chicken\n 8 January  2004  Whole Legs             194. Chicken\n 9 January  2004  Thighs                  NA  Chicken\n10 February 2004  Extra Large Dozen      230  Eggs   \n11 February 2004  Extra Large 1/2 Dozen  134. Eggs   \n12 February 2004  Large Dozen            226. Eggs   \n13 February 2004  Large 1/2 Dozen        128. Eggs   \n14 February 2004  Whole                  198. Chicken\n15 February 2004  B/S Breast             642. Chicken\n16 February 2004  Bone-in Breast          NA  Chicken\n17 February 2004  Whole Legs             194. Chicken\n18 February 2004  Thighs                 203  Chicken\n# … with 1,062 more rows\n```\n:::\n:::\n\n\n### Briefly describe the data\n\nThe data describes the price of several types of USDA certified organic egg and chicken products from the years 2004 to 2013. The price was paid by 'first receivers', described in a footnote as \"those entities that purchases the processed product from the poultry or egg company, such as a retailer, distributor, or manufacturer.\" The cited data sources are the U.S. Department of Agriculture, Agricultural Marketing Service (AMS) Market News, Organic Poultry and Eggs (Weekly reports).\n\nThe data includes 5 variables (date, 4 egg carton items and 5 chicken items, and an empty column) with prices for 3 items for each month of 10 years in 1076 rows.\n\n\n## Task 2) Identify variables that need to be mutated\n\nIn the Tidying code block above, I pivot the source data columns to a single `item` column. I then use several mutate functions to make the data more consistent and apply labels from other metadata taken from the original header.\n\nI also use mutate to create a month and year column, but these variables are still character data types. \n\nThe `lubridate` package wants to use dates or datetimes. It can do calculations with periods such as months, but the output is still dates or datetimes rather than months. I could pick the 1st of each month to work around this limitation, but there's another option ...\n\nThe `zoo` package `yearmon` class can return a year and month combo to represent dates on in monthly units. I like that! I decided to use `zoo` instead of `lubridate` for this specific case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eggPoultryData$monthYear <- as.yearmon(paste(df_eggPoultryData$year, df_eggPoultryData$month), \"%Y %B\") # turn combine month and year strings into a yearmon data type column\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.yearmon(paste(df_eggPoultryData$year, df_eggPoultryData$month), : could not find function \"as.yearmon\"\n```\n:::\n\n```{.r .cell-code}\ndf_eggPoultryData <- subset(df_eggPoultryData, select = -c(month, year)) %>%\n  relocate(monthYear) %>% # we no longer need the month and year string columns\n  print(n=18)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `relocate()`:\n! Can't subset columns that don't exist.\n✖ Column `monthYear` doesn't exist.\n```\n:::\n:::\n\n\nNow I can summarize price information by item. There are 9 items, so this table has only 9 rows. (I also updated the `find_mode` function from the version I used in Challenge 2 -- it now omits NA values, which makes the calculation of mode consistent with how I'm using other summary calculations.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define function to calculate mode\nfind_mode <- function(x) {\n  u <- unique(x[!is.na(x)]) # unique list as an index, without NA\n  tab <- tabulate(match(x[!is.na(x)], u))  # count how many times each index member occurs\n  u[tab == max(tab)] #  the max occurrence is the mode\n  mean(u) # return mean in case the data is multimodal\n}\n\ndf_eggPoultryData %>% \n  group_by(item) %>% \n  summarise(\n    meanPrice = mean(price, na.rm = TRUE), \n    modePrice = find_mode(price), \n    minPrice = fivenum(price, na.rm = TRUE)[1], \n    lowHingePrice = fivenum(price, na.rm = TRUE)[2], \n    medianPrice = median(price, na.rm = TRUE), \n    upHungePrice = fivenum(price, na.rm = TRUE)[4], \n    maxPrice = fivenum(price, na.rm = TRUE)[5], \n    count = n()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 9\n  item             meanP…¹ modeP…² minPr…³ lowHi…⁴ media…⁵ upHun…⁶ maxPr…⁷ count\n  <chr>              <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <int>\n1 B/S Breast          655.    657.    638.    645.    646.    646.    704.   120\n2 Bone-in Breast      390.    390.    390.    390.    390.    390.    390.   120\n3 Extra Large 1/2…    164.    147.    132     136.    186.    186.    188.   120\n4 Extra Large Doz…    267.    252.    230     242.    286.    286.    290    120\n5 Large 1/2 Dozen     155.    144.    126     129.    174.    174.    178    120\n6 Large Dozen         254.    248.    225     234.    268.    268     278.   120\n7 Thighs              218.    211.    200.    215     222     222     222    120\n8 Whole               231.    222.    198.    220.    235     238.    248    120\n9 Whole Legs          203.    200.    194.    204.    204.    204.    204.   120\n# … with abbreviated variable names ¹​meanPrice, ²​modePrice, ³​minPrice,\n#   ⁴​lowHingePrice, ⁵​medianPrice, ⁶​upHungePrice, ⁷​maxPrice\n```\n:::\n:::\n\n\nOr by month and item (this time using `lubridate`!). I expect this table to show 108 rows = 9 items * 12 months.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eggPoultryData %>% \n  group_by(month = month(monthYear, label = TRUE), item) %>% \n  summarise(\n    meanPrice = mean(price, na.rm = TRUE), \n    modePrice = find_mode(price), \n    minPrice = fivenum(price, na.rm = TRUE)[1], \n    lowHingePrice = fivenum(price, na.rm = TRUE)[2], \n    medianPrice = median(price, na.rm = TRUE), \n    upHungePrice = fivenum(price, na.rm = TRUE)[4], \n    maxPrice = fivenum(price, na.rm = TRUE)[5], \n    count = n()\n    )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `group_by()`:\nℹ In argument: `month = month(monthYear, label = TRUE)`.\nCaused by error in `month()`:\n! object 'monthYear' not found\n```\n:::\n:::\n\n\nOr by product. One row each for eggs and chicken.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eggPoultryData %>% \n  group_by(product) %>% \n  summarise(\n    meanPrice = mean(price, na.rm = TRUE), \n    modePrice = find_mode(price), \n    minPrice = fivenum(price, na.rm = TRUE)[1], \n    lowHingePrice = fivenum(price, na.rm = TRUE)[2], \n    medianPrice = median(price, na.rm = TRUE), \n    upHungePrice = fivenum(price, na.rm = TRUE)[4], \n    maxPrice = fivenum(price, na.rm = TRUE)[5], \n    count = n()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 9\n  product meanPrice modePrice minPrice lowHingeP…¹ media…² upHun…³ maxPr…⁴ count\n  <chr>       <dbl>     <dbl>    <dbl>       <dbl>   <dbl>   <dbl>   <dbl> <int>\n1 Chicken      339.      331.     194.        215     235     390.    704.   600\n2 Eggs         210.      204.     126         174.    207.    268.    290    480\n# … with abbreviated variable names ¹​lowHingePrice, ²​medianPrice,\n#   ³​upHungePrice, ⁴​maxPrice\n```\n:::\n:::\n\n\nOr by year and product. Ten years of eggs and chicken, in 20 rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eggPoultryData %>% \n  group_by(year = year(monthYear), product) %>% \n  summarise(\n    meanPrice = mean(price, na.rm = TRUE), \n    modePrice = find_mode(price), \n    minPrice = fivenum(price, na.rm = TRUE)[1], \n    lowHingePrice = fivenum(price, na.rm = TRUE)[2], \n    medianPrice = median(price, na.rm = TRUE), \n    upHungePrice = fivenum(price, na.rm = TRUE)[4], \n    maxPrice = fivenum(price, na.rm = TRUE)[5], \n    count = n()\n    )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `group_by()`:\nℹ In argument: `year = year(monthYear)`.\nCaused by error in `year()`:\n! object 'monthYear' not found\n```\n:::\n:::",
    "supporting": [
      "TimShores_challenge4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}