{
  "hash": "3d738630a2165d4590123d33b36053e5",
  "result": {
    "markdown": "---\ntitle: \"Challenge 3 Instructions\"\nauthor: \"Kevin Martell Luya\"\ndescription: \"Tidy Data: Pivoting\"\ndate: \"04/21/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_3\n  - animal_weights\n  - eggs\n  - australian_marriage\n  - usa_households\n  - sce_labor\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(lattice)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1.  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2.  identify what needs to be done to tidy the current data\n3.  anticipate the shape of pivoted data\n4.  pivot the data into tidy format using `pivot_longer`\n\n## Read in data\n\nRead in one (or more) of the following datasets, using the correct R package and command.\n\n-   animal_weights.csv ‚≠ê\n-   eggs_tidy.csv ‚≠ê‚≠ê or organiceggpoultry.xls ‚≠ê‚≠ê‚≠ê\n-   australian_marriage\\*.xls ‚≠ê‚≠ê‚≠ê\n-   USA Households\\*.xlsx ‚≠ê‚≠ê‚≠ê‚≠ê\n-   sce_labor_chart_data_public.xlsx üåüüåüüåüüåüüåü\n\n\n::: {.cell}\n\n:::\n\n\n### Briefly describe the data\n\nDescribe the data, and be sure to comment on why you are planning to pivot it to make it \"tidy\"\n\n## Anticipate the End Result\n\nThe first step in pivoting the data is to try to come up with a concrete vision of what the end product *should* look like - that way you will know whether or not your pivoting was successful.\n\nOne easy way to do this is to think about the dimensions of your current data (tibble, dataframe, or matrix), and then calculate what the dimensions of the pivoted data should be.\n\nSuppose you have a dataset with $n$ rows and $k$ variables. In our example, 3 of the variables are used to identify a case, so you will be pivoting $k-3$ variables into a longer format where the $k-3$ variable names will move into the `names_to` variable and the current values in each of those columns will move into the `values_to` variable. Therefore, we would expect $n * (k-3)$ rows in the pivoted dataframe!\n\n### Example: find current and future data dimensions\n\nLets see if this works with a simple example.\n\n\n::: {.cell tbl-cap='Example'}\n\n```{.r .cell-code}\ndf<-tibble(country = rep(c(\"Mexico\", \"USA\", \"France\"),2),\n           year = rep(c(1980,1990), 3), \n           trade = rep(c(\"NAFTA\", \"NAFTA\", \"EU\"),2),\n           outgoing = rnorm(6, mean=1000, sd=500),\n           incoming = rlogis(6, location=1000, \n                             scale = 400))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 5\n  country  year trade outgoing incoming\n  <chr>   <dbl> <chr>    <dbl>    <dbl>\n1 Mexico   1980 NAFTA     909.    -511.\n2 USA      1990 NAFTA     491.    1248.\n3 France   1980 EU       1133.    1311.\n4 Mexico   1990 NAFTA    1190.    1417.\n5 USA      1980 NAFTA     807.    1726.\n6 France   1990 EU       1139.     848.\n```\n:::\n\n```{.r .cell-code}\n#existing rows/cases\nnrow(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n#existing columns/cases\nncol(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n#expected rows/cases\nnrow(df) * (ncol(df)-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n\n```{.r .cell-code}\n# expected columns \n3 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nOr simple example has $n = 6$ rows and $k - 3 = 2$ variables being pivoted, so we expect a new dataframe to have $n * 2 = 12$ rows x $3 + 2 = 5$ columns.\n\n### Challenge: Describe the final dimensions\n\nDocument your work here.\n\n\n::: {.cell}\n\n:::\n\n\nAny additional comments?\n\n## Pivot the Data\n\nNow we will pivot the data, and compare our pivoted data dimensions to the dimensions calculated above as a \"sanity\" check.\n\n### Example\n\n\n::: {.cell tbl-cap='Pivoted Example'}\n\n```{.r .cell-code}\ndf<-pivot_longer(df, col = c(outgoing, incoming),\n                 names_to=\"trade_direction\",\n                 values_to = \"trade_value\")\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 √ó 5\n   country  year trade trade_direction trade_value\n   <chr>   <dbl> <chr> <chr>                 <dbl>\n 1 Mexico   1980 NAFTA outgoing               909.\n 2 Mexico   1980 NAFTA incoming              -511.\n 3 USA      1990 NAFTA outgoing               491.\n 4 USA      1990 NAFTA incoming              1248.\n 5 France   1980 EU    outgoing              1133.\n 6 France   1980 EU    incoming              1311.\n 7 Mexico   1990 NAFTA outgoing              1190.\n 8 Mexico   1990 NAFTA incoming              1417.\n 9 USA      1980 NAFTA outgoing               807.\n10 USA      1980 NAFTA incoming              1726.\n11 France   1990 EU    outgoing              1139.\n12 France   1990 EU    incoming               848.\n```\n:::\n:::\n\n\nYes, once it is pivoted long, our resulting data are $12x5$ - exactly what we expected!\n\n### Challenge: Pivot the Chosen Data\n\nDocument your work here. What will a new \"case\" be once you have pivoted the data? How does it meet requirements for tidy data?\n\nIt is evident that certain columns derive from another ( percentages and total columns which can be obtained from the other columns.We also notice that there are rows with empty values and rows with strings \"<<DISTRICT_NAME>> (Total)\". Let's remove them and keep it simple with essential data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_excel(\"_data/australian_marriage_law_postal_survey_2017_-_response_final.xls\",\n           sheet=\"Table 2\",\n           skip=7,\n           col_names = c(\"DISTRICT\",\"YES\",\"_trash\",\"NO\",rep(\"_trash\",6),\"RESPONSE_NOT_CLEAR\",\"_trash\",\"NO_RESPONSE\",rep(\"_trash\",3)))%>%\n  select(!contains(\"_trash\"))%>%\n  drop_na(DISTRICT)%>%\n  head(-7)%>%\n  filter(!str_detect(DISTRICT,\"(Total)\"))\n\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 159 √ó 5\n   DISTRICT                    YES    NO RESPONSE_NOT_CLEAR NO_RESPONSE\n   <chr>                     <dbl> <dbl>              <dbl>       <dbl>\n 1 New South Wales Divisions    NA    NA                 NA          NA\n 2 Banks                     37736 46343                247       20928\n 3 Barton                    37153 47984                226       24008\n 4 Bennelong                 42943 43215                244       19973\n 5 Berowra                   48471 40369                212       16038\n 6 Blaxland                  20406 57926                220       25883\n 7 Bradfield                 53681 34927                202       17261\n 8 Calare                    54091 35779                285       25342\n 9 Chifley                   32871 46702                263       28180\n10 Cook                      47505 38804                229       18713\n# ‚Ä¶ with 149 more rows\n```\n:::\n:::\n\n\n\nNext, let's add a new column called Division and set each row value according to\nthe District division name until we find a new one. Then we repeat the  process \nof setting the District divisions name to the rows that are below.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <-data %>%\n  mutate(DIVISION = case_when(\n    str_detect(DISTRICT, \"Divisions\") ~ DISTRICT,\n    TRUE ~ NA_character_ ))%>%\n  fill(DIVISION, .direction = \"down\") %>%\n  filter(!str_detect(DISTRICT, \"Division\"))\n\n# remove Australia\ndata <- filter(data, !str_detect(DISTRICT, \"Australia\"))\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 √ó 6\n   DISTRICT    YES    NO RESPONSE_NOT_CLEAR NO_RESPONSE DIVISION                \n   <chr>     <dbl> <dbl>              <dbl>       <dbl> <chr>                   \n 1 Banks     37736 46343                247       20928 New South Wales Divisio‚Ä¶\n 2 Barton    37153 47984                226       24008 New South Wales Divisio‚Ä¶\n 3 Bennelong 42943 43215                244       19973 New South Wales Divisio‚Ä¶\n 4 Berowra   48471 40369                212       16038 New South Wales Divisio‚Ä¶\n 5 Blaxland  20406 57926                220       25883 New South Wales Divisio‚Ä¶\n 6 Bradfield 53681 34927                202       17261 New South Wales Divisio‚Ä¶\n 7 Calare    54091 35779                285       25342 New South Wales Divisio‚Ä¶\n 8 Chifley   32871 46702                263       28180 New South Wales Divisio‚Ä¶\n 9 Cook      47505 38804                229       18713 New South Wales Divisio‚Ä¶\n10 Cowper    57493 38317                315       25197 New South Wales Divisio‚Ä¶\n# ‚Ä¶ with 140 more rows\n```\n:::\n:::\n\n\nLet's pivot the data to get all the response types in one column per district \nwith its respective counts\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_longe <- pivot_longer(\n  data,\n  cols = YES:NO_RESPONSE,\n  names_to = \"Response\",\n  values_to = \"Count\"\n \n)\ndata_longe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 600 √ó 4\n   DISTRICT  DIVISION                  Response           Count\n   <chr>     <chr>                     <chr>              <dbl>\n 1 Banks     New South Wales Divisions YES                37736\n 2 Banks     New South Wales Divisions NO                 46343\n 3 Banks     New South Wales Divisions RESPONSE_NOT_CLEAR   247\n 4 Banks     New South Wales Divisions NO_RESPONSE        20928\n 5 Barton    New South Wales Divisions YES                37153\n 6 Barton    New South Wales Divisions NO                 47984\n 7 Barton    New South Wales Divisions RESPONSE_NOT_CLEAR   226\n 8 Barton    New South Wales Divisions NO_RESPONSE        24008\n 9 Bennelong New South Wales Divisions YES                42943\n10 Bennelong New South Wales Divisions NO                 43215\n# ‚Ä¶ with 590 more rows\n```\n:::\n:::\n\nAs a result we pivoted the dataset, but one step is missing if we want to\nvisualize a barchat. Let's mutate Responses and get the 4 categories by using \nfactor.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_visualize <- data_longe%>%\n  mutate(Response = factor(Response))\n\nsummary(data_visualize)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   DISTRICT           DIVISION                       Response       Count      \n Length:600         Length:600         NO                :150   Min.   :  106  \n Class :character   Class :character   NO_RESPONSE       :150   1st Qu.: 9913  \n Mode  :character   Mode  :character   RESPONSE_NOT_CLEAR:150   Median :25477  \n                                       YES               :150   Mean   :26677  \n                                                                3rd Qu.:40019  \n                                                                Max.   :89590  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbarchart( Count ~ Response , group = DIVISION , data = data_visualize) \n```\n\n::: {.cell-output-display}\n![](KevinMartell_challenge3_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThis is the final visualization after using pivoting longe.\n",
    "supporting": [
      "KevinMartell_challenge3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}